var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};

// pkg/admin.ts
var Admin = class {
  constructor(client) {
    this.client = client;
  }
  async topics() {
    return await this.client.get({ path: ["topics"] });
  }
  async consumers() {
    return await this.client.get({ path: ["consumers"] });
  }
  async removeConsumerInstance(consumerGroup, instanceId) {
    await this.client.post({
      path: ["delete-consumer", consumerGroup, instanceId]
    });
  }
  async committedOffsets(req) {
    return await this.client.post({
      path: ["committed", req.consumerGroupId, req.instanceId],
      body: req.topicPartition ? [req.topicPartition] : req.topicPartitions
    });
  }
  async topicPartitionOffsets(req) {
    return await this.client.post({
      path: ["offsets", req.timestamp.toString()],
      body: req.topicPartition ? [req.topicPartition] : req.topicPartitions
    });
  }
};

// pkg/producer.ts
var Producer = class {
  constructor(client) {
    this.client = client;
  }
  async produce(topic, message, opts) {
    const request = __spreadValues({
      topic,
      value: typeof message === "string" ? message : JSON.stringify(message)
    }, opts);
    const res = await this.client.post({
      path: ["produce"],
      body: request
    });
    return res[0];
  }
  async produceMany(requests) {
    requests = requests.map((_a) => {
      var _b = _a, { value } = _b, rest = __objRest(_b, ["value"]);
      return __spreadProps(__spreadValues({}, rest), {
        value: typeof value === "string" ? value : JSON.stringify(value)
      });
    });
    return await this.client.post({
      path: ["produce"],
      body: requests
    });
  }
};

// pkg/consumer.ts
var Consumer = class {
  constructor(client) {
    this.client = client;
  }
  async fetch(req, opts = { parallel: true }) {
    var _a;
    let requests = [req];
    if (opts == null ? void 0 : opts.parallel) {
      requests = ((_a = req.topicPartitionOffsets) != null ? _a : []).map((r) => __spreadProps(__spreadValues({}, r), { timeout: req.timeout }));
      if (req.topic) {
        requests.push({
          topic: req.topic,
          partition: req.partition,
          offset: req.offset,
          timeout: req.timeout
        });
      }
    }
    const responses = await Promise.all(requests.map(async (r) => await this.client.post({ path: ["fetch"], body: r })));
    return responses.flat();
  }
  async consume(req) {
    const body = {};
    if (req.topics.length === 1) {
      body.topic = req.topics[0];
    } else {
      body.topics = req.topics;
    }
    if (typeof req.timeout === "number") {
      body.timeout = req.timeout;
    }
    const headers = {};
    if (typeof req.autoCommit === "boolean") {
      headers["Kafka-Enable-Auto-Commit"] = req.autoCommit.toString();
    }
    if (typeof req.autoCommitInterval === "number") {
      headers["Kafka-Auto-Commit-Interval"] = req.autoCommitInterval.toString();
    }
    if (typeof req.autoOffsetReset === "string") {
      headers["Kafka-Auto-Offset-Reset"] = req.autoOffsetReset;
    }
    return await this.client.post({
      path: ["consume", req.consumerGroupId, req.instanceId],
      headers,
      body
    });
  }
  async commit(req) {
    return await this.client.post({
      path: ["commit", req.consumerGroupId, req.instanceId],
      body: req.offset
    });
  }
  async committed(req) {
    return await this.client.post({
      path: ["committed", req.consumerGroupId, req.instanceId],
      body: req.topicPartitions
    });
  }
};

// pkg/http.ts
import "isomorphic-fetch";

// pkg/error.ts
var UpstashError = class extends Error {
  constructor(res) {
    super(res.error);
    this.name = "UpstashError";
    this.result = res.result;
    this.error = res.error;
    this.status = res.status;
  }
};

// pkg/http.ts
var HttpClient = class {
  constructor(config) {
    var _a;
    this.baseUrl = config.baseUrl.replace(/\/$/, "");
    this.headers = (_a = config.headers) != null ? _a : {};
  }
  async request(method, req) {
    var _a;
    const headers = __spreadValues(__spreadValues({
      "Content-Type": "application/json"
    }, this.headers), req.headers);
    let err = new Error();
    for (let attempt = 0; attempt <= ((_a = req.retries) != null ? _a : 5); attempt++) {
      if (attempt > 0) {
        await new Promise((r) => setTimeout(r, 2 ** attempt * 250));
      }
      try {
        const res = await fetch([this.baseUrl, ...req.path].join("/"), {
          method,
          headers,
          body: JSON.stringify(req.body)
        });
        const body = await res.json();
        if (!res.ok) {
          throw new UpstashError(body);
        }
        return body;
      } catch (e) {
        err = e;
      }
    }
    throw err;
  }
  async get(req) {
    return await this.request("GET", req);
  }
  async post(req) {
    return await this.request("POST", req);
  }
};

// pkg/base64.ts
function base64(origin) {
  const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
  const len = origin.length - 1;
  let i = -1;
  let encoded = "";
  while (i < len) {
    const code = origin.charCodeAt(++i) << 16 | origin.charCodeAt(++i) << 8 | origin.charCodeAt(++i);
    encoded += alphabet[code >>> 18 & 63] + alphabet[code >>> 12 & 63] + alphabet[code >>> 6 & 63] + alphabet[code & 63];
  }
  var pads = origin.length % 3;
  if (pads > 0) {
    encoded = encoded.slice(0, pads - 3);
    while (encoded.length % 4 !== 0) {
      encoded += "=";
    }
  }
  return encoded;
}

// pkg/kafka.ts
var Kafka = class {
  constructor(config) {
    this.client = new HttpClient({
      baseUrl: config.url,
      headers: {
        authorization: `Basic ${base64(`${config.username}:${config.password}`)}`
      }
    });
  }
  producer() {
    return new Producer(this.client);
  }
  consumer() {
    return new Consumer(this.client);
  }
  admin() {
    return new Admin(this.client);
  }
};
export {
  Kafka,
  UpstashError
};
